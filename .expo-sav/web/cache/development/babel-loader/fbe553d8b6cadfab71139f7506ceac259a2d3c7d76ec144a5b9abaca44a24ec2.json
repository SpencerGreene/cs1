{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport RNFetchBlob from \"../index.js\";\nimport fs from \"../fs.js\";\nimport getUUID from \"../utils/uuid\";\nimport Log from \"../utils/log.js\";\nimport EventTarget from \"./EventTarget\";\nvar log = new Log('Blob');\nvar blobCacheDir = fs.dirs.DocumentDir + '/RNFetchBlob-blobs/';\nlog.disable();\nvar Blob = function (_EventTarget) {\n  _inherits(Blob, _EventTarget);\n  var _super = _createSuper(Blob);\n  function Blob(data, cType, defer) {\n    var _this;\n    _classCallCheck(this, Blob);\n    _this = _super.call(this);\n    _this.isRNFetchBlobPolyfill = true;\n    _this.multipartBoundary = null;\n    _this._ref = null;\n    _this._blobCreated = false;\n    _this._onCreated = [];\n    _this._closed = false;\n    cType = cType || {};\n    _this.cacheName = getBlobName();\n    _this.isRNFetchBlobPolyfill = true;\n    _this.isDerived = defer;\n    _this.type = cType.type || 'text/plain';\n    log.verbose('Blob constructor called', 'mime', _this.type, 'type', typeof data, 'length', data ? data.length : 0);\n    _this._ref = blobCacheDir + _this.cacheName;\n    var p = null;\n    if (!data) data = '';\n    if (data.isRNFetchBlobPolyfill) {\n      log.verbose('create Blob cache file from Blob object');\n      var size = 0;\n      _this._ref = String(data.getRNFetchBlobRef());\n      var orgPath = _this._ref;\n      p = fs.exists(orgPath).then(function (exist) {\n        if (exist) return fs.writeFile(orgPath, data, 'uri').then(function (size) {\n          return Promise.resolve(size);\n        }).catch(function (err) {\n          throw `RNFetchBlob Blob file creation error, ${err}`;\n        });else throw `could not create Blob from path ${orgPath}, file not exists`;\n      });\n    } else if (data instanceof FormData) {\n      log.verbose('create Blob cache file from FormData', data);\n      var boundary = `RNFetchBlob-${_this.cacheName}-${Date.now()}`;\n      _this.multipartBoundary = boundary;\n      var parts = data.getParts();\n      var formArray = [];\n      if (!parts) {\n        p = fs.writeFile(_this._ref, '', 'utf8');\n      } else {\n        for (var i in parts) {\n          formArray.push('\\r\\n--' + boundary + '\\r\\n');\n          var part = parts[i];\n          for (var j in part.headers) {\n            formArray.push(j + ': ' + part.headers[j] + '\\r\\n');\n          }\n          formArray.push('\\r\\n');\n          if (part.isRNFetchBlobPolyfill) formArray.push(part);else formArray.push(part.string);\n        }\n        log.verbose('FormData array', formArray);\n        formArray.push('\\r\\n--' + boundary + '--\\r\\n');\n        p = createMixedBlobData(_this._ref, formArray);\n      }\n    } else if (typeof data === 'string' && data.startsWith('RNFetchBlob-file://')) {\n      log.verbose('create Blob cache file from file path', data);\n      _this._isReference = true;\n      _this._ref = String(data).replace('RNFetchBlob-file://', '');\n      var _orgPath = _this._ref;\n      if (defer) return _possibleConstructorReturn(_this);else {\n        p = fs.stat(_orgPath).then(function (stat) {\n          return Promise.resolve(stat.size);\n        });\n      }\n    } else if (typeof data === 'string') {\n      var encoding = 'utf8';\n      var mime = String(_this.type);\n      if (/(application\\/octet|\\;base64)/i.test(mime)) encoding = 'base64';else data = data.toString();\n      _this.type = String(_this.type).replace(/;base64/ig, '');\n      log.verbose('create Blob cache file from string', 'encode', encoding);\n      p = fs.writeFile(_this._ref, data, encoding).then(function (size) {\n        return Promise.resolve(size);\n      });\n    } else if (Array.isArray(data)) {\n      log.verbose('create Blob cache file from mixed array', data);\n      p = createMixedBlobData(_this._ref, data);\n    } else {\n      data = data.toString();\n      p = fs.writeFile(_this._ref, data, 'utf8').then(function (size) {\n        return Promise.resolve(size);\n      });\n    }\n    p && p.then(function (size) {\n      _this.size = size;\n      _this._invokeOnCreateEvent();\n    }).catch(function (err) {\n      log.error('RNFetchBlob could not create Blob : ' + _this._ref, err);\n    });\n    return _this;\n  }\n  _createClass(Blob, [{\n    key: \"blobPath\",\n    get: function get() {\n      return this._ref;\n    }\n  }, {\n    key: \"onCreated\",\n    value: function onCreated(fn) {\n      log.verbose('#register blob onCreated', this._blobCreated);\n      if (!this._blobCreated) this._onCreated.push(fn);else {\n        fn(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"markAsDerived\",\n    value: function markAsDerived() {\n      this._isDerived = true;\n    }\n  }, {\n    key: \"isDerived\",\n    get: function get() {\n      return this._isDerived || false;\n    }\n  }, {\n    key: \"getRNFetchBlobRef\",\n    value: function getRNFetchBlobRef() {\n      return this._ref;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      var _this2 = this;\n      var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (this._closed) throw 'Blob has been released.';\n      log.verbose('slice called', start, end, contentType);\n      var resPath = blobCacheDir + getBlobName();\n      var pass = false;\n      log.debug('fs.slice new blob will at', resPath);\n      var result = new Blob(RNFetchBlob.wrap(resPath), {\n        type: contentType\n      }, true);\n      fs.exists(blobCacheDir).then(function (exist) {\n        if (exist) return Promise.resolve();\n        return fs.mkdir(blobCacheDir);\n      }).then(function () {\n        return fs.slice(_this2._ref, resPath, start, end);\n      }).then(function (dest) {\n        log.debug('fs.slice done', dest);\n        result._invokeOnCreateEvent();\n        pass = true;\n      }).catch(function (err) {\n        console.warn('Blob.slice failed:', err);\n        pass = true;\n      });\n      log.debug('slice returning new Blob');\n      return result;\n    }\n  }, {\n    key: \"readBlob\",\n    value: function readBlob(encoding) {\n      if (this._closed) throw 'Blob has been released.';\n      return fs.readFile(this._ref, encoding || 'utf8');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._closed) return Promise.reject('Blob has been released.');\n      this._closed = true;\n      return fs.unlink(this._ref).catch(function (err) {\n        console.warn(err);\n      });\n    }\n  }, {\n    key: \"safeClose\",\n    value: function safeClose() {\n      if (this._closed) return Promise.reject('Blob has been released.');\n      this._closed = true;\n      if (!this._isReference) {\n        return fs.unlink(this._ref).catch(function (err) {\n          console.warn(err);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"_invokeOnCreateEvent\",\n    value: function _invokeOnCreateEvent() {\n      log.verbose('invoke create event', this._onCreated);\n      this._blobCreated = true;\n      var fns = this._onCreated;\n      for (var i in fns) {\n        if (typeof fns[i] === 'function') {\n          fns[i](this);\n        }\n      }\n      delete this._onCreated;\n    }\n  }], [{\n    key: \"clearCache\",\n    value: function clearCache() {\n      return fs.unlink(blobCacheDir).then(function () {\n        return fs.mkdir(blobCacheDir);\n      });\n    }\n  }, {\n    key: \"build\",\n    value: function build(data, cType) {\n      return new Promise(function (resolve, reject) {\n        new Blob(data, cType).onCreated(resolve);\n      });\n    }\n  }, {\n    key: \"setLog\",\n    value: function setLog(level) {\n      if (level === -1) log.disable();else log.level(level);\n    }\n  }]);\n  return Blob;\n}(EventTarget);\nexport { Blob as default };\nfunction getBlobName() {\n  return 'blob-' + getUUID();\n}\nfunction createMixedBlobData(ref, dataArray) {\n  var p = fs.writeFile(ref, '');\n  var args = [];\n  var size = 0;\n  for (var i in dataArray) {\n    var part = dataArray[i];\n    if (!part) continue;\n    if (part.isRNFetchBlobPolyfill) {\n      args.push([ref, part._ref, 'uri']);\n    } else if (typeof part === 'string') args.push([ref, part, 'utf8']);else if (Array.isArray(part)) args.push([ref, part, 'ascii']);\n  }\n  var _loop = function _loop(_i) {\n    p = p.then(function (written) {\n      var arg = this;\n      if (written) size += written;\n      log.verbose('mixed blob write', args[_i], written);\n      return fs.appendFile.apply(fs, _toConsumableArray(arg));\n    }.bind(args[_i]));\n  };\n  for (var _i in args) {\n    _loop(_i);\n  }\n  return p.then(function () {\n    return Promise.resolve(size);\n  });\n}","map":{"version":3,"names":["RNFetchBlob","fs","getUUID","Log","EventTarget","log","blobCacheDir","dirs","DocumentDir","disable","Blob","_EventTarget","_inherits","_super","_createSuper","data","cType","defer","_this","_classCallCheck","call","isRNFetchBlobPolyfill","multipartBoundary","_ref","_blobCreated","_onCreated","_closed","cacheName","getBlobName","isDerived","type","verbose","length","p","size","String","getRNFetchBlobRef","orgPath","exists","then","exist","writeFile","Promise","resolve","catch","err","FormData","boundary","Date","now","parts","getParts","formArray","i","push","part","j","headers","string","createMixedBlobData","startsWith","_isReference","replace","_possibleConstructorReturn","stat","encoding","mime","test","toString","Array","isArray","_invokeOnCreateEvent","error","_createClass","key","get","value","onCreated","fn","markAsDerived","_isDerived","slice","start","end","_this2","contentType","arguments","undefined","resPath","pass","debug","result","wrap","mkdir","dest","console","warn","readBlob","readFile","close","reject","unlink","safeClose","fns","clearCache","build","setLog","level","default","ref","dataArray","args","_loop","_i","written","arg","appendFile","apply","_toConsumableArray","bind"],"sources":["/Users/sgreene/src/cs1/node_modules/react-native-fetch-blob/polyfill/Blob.js"],"sourcesContent":["// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport fs from '../fs.js'\nimport getUUID from '../utils/uuid'\nimport Log from '../utils/log.js'\nimport EventTarget from './EventTarget'\n\nconst log = new Log('Blob')\nconst blobCacheDir = fs.dirs.DocumentDir + '/RNFetchBlob-blobs/'\n\nlog.disable()\n// log.level(3)\n\n/**\n * A RNFetchBlob style Blob polyfill class, this is a Blob which compatible to\n * Response object attain fron RNFetchBlob.fetch.\n */\nexport default class Blob extends EventTarget {\n\n  cacheName:string;\n  type:string;\n  size:number;\n  isRNFetchBlobPolyfill:boolean = true;\n  multipartBoundary:string = null;\n\n  _ref:string = null;\n  _blobCreated:boolean = false;\n  _onCreated:Array<any> = [];\n  _closed:boolean = false;\n\n  /**\n   * Static method that remove all files in Blob cache folder.\n   * @nonstandard\n   * @return {Promise}\n   */\n  static clearCache() {\n    return fs.unlink(blobCacheDir).then(() => fs.mkdir(blobCacheDir))\n  }\n\n  static build(data:any, cType:any):Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      new Blob(data, cType).onCreated(resolve)\n    })\n  }\n\n  get blobPath() {\n    return this._ref\n  }\n\n  static setLog(level:number) {\n    if(level === -1)\n      log.disable()\n    else\n      log.level(level)\n  }\n\n  /**\n   * RNFetchBlob Blob polyfill, create a Blob directly from file path, BASE64\n   * encoded data, and string. The conversion is done implicitly according to\n   * given `mime`. However, the blob creation is asynchronously, to register\n   * event `onCreated` is need to ensure the Blob is creadted.\n   * @param  {any} data Content of Blob object\n   * @param  {any} mime Content type settings of Blob object, `text/plain`\n   *                    by default\n   * @param  {boolean} defer When this argument set to `true`, blob constructor\n   *                         will not invoke blob created event automatically.\n   */\n  constructor(data:any, cType:any, defer:boolean) {\n    super()\n    cType = cType || {}\n    this.cacheName = getBlobName()\n    this.isRNFetchBlobPolyfill = true\n    this.isDerived = defer\n    this.type = cType.type || 'text/plain'\n    log.verbose('Blob constructor called', 'mime', this.type, 'type', typeof data, 'length', data?  data.length:0)\n    this._ref = blobCacheDir + this.cacheName\n    let p = null\n    if(!data)\n      data = ''\n    if(data.isRNFetchBlobPolyfill) {\n      log.verbose('create Blob cache file from Blob object')\n      let size = 0\n      this._ref = String(data.getRNFetchBlobRef())\n      let orgPath = this._ref\n\n      p = fs.exists(orgPath)\n            .then((exist) =>  {\n              if(exist)\n                return fs.writeFile(orgPath, data, 'uri')\n                         .then((size) => Promise.resolve(size))\n                         .catch((err) => {\n                           throw `RNFetchBlob Blob file creation error, ${err}`\n                         })\n              else\n                throw `could not create Blob from path ${orgPath}, file not exists`\n            })\n    }\n    // process FormData\n    else if(data instanceof FormData) {\n      log.verbose('create Blob cache file from FormData', data)\n      let boundary = `RNFetchBlob-${this.cacheName}-${Date.now()}`\n      this.multipartBoundary = boundary\n      let parts = data.getParts()\n      let formArray = []\n      if(!parts) {\n        p = fs.writeFile(this._ref, '', 'utf8')\n      }\n      else {\n        for(let i in parts) {\n          formArray.push('\\r\\n--'+boundary+'\\r\\n')\n          let part = parts[i]\n          for(let j in part.headers) {\n            formArray.push(j + ': ' +part.headers[j] + '\\r\\n')\n          }\n          formArray.push('\\r\\n')\n          if(part.isRNFetchBlobPolyfill)\n            formArray.push(part)\n          else\n            formArray.push(part.string)\n        }\n        log.verbose('FormData array', formArray)\n        formArray.push('\\r\\n--'+boundary+'--\\r\\n')\n        p = createMixedBlobData(this._ref, formArray)\n      }\n    }\n    // if the data is a string starts with `RNFetchBlob-file://`, append the\n    // Blob data from file path\n    else if(typeof data === 'string' && data.startsWith('RNFetchBlob-file://')) {\n      log.verbose('create Blob cache file from file path', data)\n      // set this flag so that we know this blob is a wrapper of an existing file\n      this._isReference = true\n      this._ref = String(data).replace('RNFetchBlob-file://', '')\n      let orgPath = this._ref\n      if(defer)\n        return\n      else {\n        p = fs.stat(orgPath)\n              .then((stat) =>  {\n                return Promise.resolve(stat.size)\n              })\n      }\n    }\n    // content from variable need create file\n    else if(typeof data === 'string') {\n      let encoding = 'utf8'\n      let mime = String(this.type)\n      // when content type contains application/octet* or *;base64, RNFetchBlob\n      // fs will treat it as BASE64 encoded string binary data\n      if(/(application\\/octet|\\;base64)/i.test(mime))\n        encoding = 'base64'\n      else\n        data = data.toString()\n      // create cache file\n      this.type = String(this.type).replace(/;base64/ig, '')\n      log.verbose('create Blob cache file from string', 'encode', encoding)\n      p = fs.writeFile(this._ref, data, encoding)\n            .then((size) => {\n              return Promise.resolve(size)\n            })\n\n    }\n    // TODO : ArrayBuffer support\n    // else if (data instanceof ArrayBuffer ) {\n    //\n    // }\n    // when input is an array of mixed data types, create a file cache\n    else if(Array.isArray(data)) {\n      log.verbose('create Blob cache file from mixed array', data)\n      p = createMixedBlobData(this._ref, data)\n    }\n    else {\n      data = data.toString()\n      p = fs.writeFile(this._ref, data, 'utf8')\n            .then((size) => Promise.resolve(size))\n    }\n    p && p.then((size) => {\n      this.size = size\n      this._invokeOnCreateEvent()\n    })\n    .catch((err) => {\n      log.error('RNFetchBlob could not create Blob : '+ this._ref, err)\n    })\n\n  }\n\n  /**\n   * Since Blob content will asynchronously write to a file during creation,\n   * use this method to register an event handler for Blob initialized event.\n   * @nonstandard\n   * @param  {(b:Blob) => void} An event handler invoked when Blob created\n   * @return {Blob} The Blob object instance itself\n   */\n  onCreated(fn:() => void):Blob {\n    log.verbose('#register blob onCreated', this._blobCreated)\n    if(!this._blobCreated)\n      this._onCreated.push(fn)\n    else {\n      fn(this)\n    }\n    return this\n  }\n\n  markAsDerived() {\n    this._isDerived = true\n  }\n\n  get isDerived() {\n    return this._isDerived || false\n  }\n\n  /**\n   * Get file reference of the Blob object.\n   * @nonstandard\n   * @return {string} Blob file reference which can be consumed by RNFetchBlob fs\n   */\n  getRNFetchBlobRef() {\n    return this._ref\n  }\n\n  /**\n   * Create a Blob object which is sliced from current object\n   * @param  {number} start    Start byte number\n   * @param  {number} end      End byte number\n   * @param  {string} contentType Optional, content type of new Blob object\n   * @return {Blob}\n   */\n  slice(start:?number, end:?number, contentType:?string=''):Blob {\n    if(this._closed)\n      throw 'Blob has been released.'\n    log.verbose('slice called', start, end, contentType)\n\n\n    let resPath = blobCacheDir + getBlobName()\n    let pass = false\n    log.debug('fs.slice new blob will at', resPath)\n    let result = new Blob(RNFetchBlob.wrap(resPath), { type : contentType }, true)\n    fs.exists(blobCacheDir)\n    .then((exist) => {\n      if(exist)\n        return Promise.resolve()\n      return fs.mkdir(blobCacheDir)\n    })\n    .then(() => fs.slice(this._ref, resPath, start, end))\n    .then((dest) => {\n      log.debug('fs.slice done', dest)\n      result._invokeOnCreateEvent()\n      pass = true\n    })\n    .catch((err) => {\n      console.warn('Blob.slice failed:', err)\n      pass = true\n    })\n    log.debug('slice returning new Blob')\n\n    return result\n  }\n\n  /**\n   * Read data of the Blob object, this is not standard method.\n   * @nonstandard\n   * @param  {string} encoding Read data with encoding\n   * @return {Promise}\n   */\n  readBlob(encoding:string):Promise<any> {\n    if(this._closed)\n      throw 'Blob has been released.'\n    return fs.readFile(this._ref, encoding || 'utf8')\n  }\n\n  /**\n   * Release the resource of the Blob object.\n   * @nonstandard\n   * @return {Promise}\n   */\n  close() {\n    if(this._closed)\n      return Promise.reject('Blob has been released.')\n    this._closed = true\n    return fs.unlink(this._ref).catch((err) => {\n      console.warn(err)\n    })\n  }\n\n  safeClose() {\n    if(this._closed)\n      return Promise.reject('Blob has been released.')\n    this._closed = true\n    if(!this._isReference) {\n      return fs.unlink(this._ref).catch((err) => {\n        console.warn(err)\n      })   \n    }\n    else {\n      return Promise.resolve()\n    }\n  }\n\n  _invokeOnCreateEvent() {\n    log.verbose('invoke create event', this._onCreated)\n    this._blobCreated = true\n    let fns = this._onCreated\n    for(let i in fns) {\n      if(typeof fns[i] === 'function') {\n        fns[i](this)\n      }\n    }\n    delete this._onCreated\n  }\n\n}\n\n/**\n * Get a temp filename for Blob object\n * @return {string} Temporary filename\n */\nfunction getBlobName() {\n  return 'blob-' + getUUID()\n}\n\n/**\n * Create a file according to given array. The element in array can be a number,\n * Blob, String, Array.\n * @param  {string} ref File path reference\n * @param  {Array} dataArray An array contains different types of data.\n * @return {Promise}\n */\nfunction createMixedBlobData(ref, dataArray) {\n  // create an empty file for store blob data\n  let p = fs.writeFile(ref, '')\n  let args = []\n  let size = 0\n  for(let i in dataArray) {\n    let part = dataArray[i]\n    if(!part)\n      continue\n    if(part.isRNFetchBlobPolyfill) {\n      args.push([ref, part._ref, 'uri'])\n    }\n    else if(typeof part === 'string')\n      args.push([ref, part, 'utf8'])\n    // TODO : ArrayBuffer\n    // else if (part instanceof ArrayBuffer) {\n    //\n    // }\n    else if (Array.isArray(part))\n      args.push([ref, part, 'ascii'])\n  }\n  // start write blob data\n  for(let i in args) {\n    p = p.then(function(written){\n      let arg = this\n      if(written)\n        size += written\n      log.verbose('mixed blob write', args[i], written)\n      return fs.appendFile(...arg)\n    }.bind(args[i]))\n  }\n  return p.then(() => Promise.resolve(size))\n}\n"],"mappings":";;;;;;;;AAIA,OAAOA,WAAW;AAClB,OAAOC,EAAE;AACT,OAAOC,OAAO;AACd,OAAOC,GAAG;AACV,OAAOC,WAAW;AAElB,IAAMC,GAAG,GAAG,IAAIF,GAAG,CAAC,MAAM,CAAC;AAC3B,IAAMG,YAAY,GAAGL,EAAE,CAACM,IAAI,CAACC,WAAW,GAAG,qBAAqB;AAEhEH,GAAG,CAACI,OAAO,CAAC,CAAC;AAAA,IAOQC,IAAI,aAAAC,YAAA;EAAAC,SAAA,CAAAF,IAAA,EAAAC,YAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,IAAA;EAkDvB,SAAAA,KAAYK,IAAQ,EAAEC,KAAS,EAAEC,KAAa,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAT,IAAA;IAC9CQ,KAAA,GAAAL,MAAA,CAAAO,IAAA;IAAOF,KAAA,CA9CTG,qBAAqB,GAAW,IAAI;IAAAH,KAAA,CACpCI,iBAAiB,GAAU,IAAI;IAAAJ,KAAA,CAE/BK,IAAI,GAAU,IAAI;IAAAL,KAAA,CAClBM,YAAY,GAAW,KAAK;IAAAN,KAAA,CAC5BO,UAAU,GAAc,EAAE;IAAAP,KAAA,CAC1BQ,OAAO,GAAW,KAAK;IAyCrBV,KAAK,GAAGA,KAAK,IAAI,CAAC,CAAC;IACnBE,KAAA,CAAKS,SAAS,GAAGC,WAAW,CAAC,CAAC;IAC9BV,KAAA,CAAKG,qBAAqB,GAAG,IAAI;IACjCH,KAAA,CAAKW,SAAS,GAAGZ,KAAK;IACtBC,KAAA,CAAKY,IAAI,GAAGd,KAAK,CAACc,IAAI,IAAI,YAAY;IACtCzB,GAAG,CAAC0B,OAAO,CAAC,yBAAyB,EAAE,MAAM,EAAEb,KAAA,CAAKY,IAAI,EAAE,MAAM,EAAE,OAAOf,IAAI,EAAE,QAAQ,EAAEA,IAAI,GAAGA,IAAI,CAACiB,MAAM,GAAC,CAAC,CAAC;IAC9Gd,KAAA,CAAKK,IAAI,GAAGjB,YAAY,GAAGY,KAAA,CAAKS,SAAS;IACzC,IAAIM,CAAC,GAAG,IAAI;IACZ,IAAG,CAAClB,IAAI,EACNA,IAAI,GAAG,EAAE;IACX,IAAGA,IAAI,CAACM,qBAAqB,EAAE;MAC7BhB,GAAG,CAAC0B,OAAO,CAAC,yCAAyC,CAAC;MACtD,IAAIG,IAAI,GAAG,CAAC;MACZhB,KAAA,CAAKK,IAAI,GAAGY,MAAM,CAACpB,IAAI,CAACqB,iBAAiB,CAAC,CAAC,CAAC;MAC5C,IAAIC,OAAO,GAAGnB,KAAA,CAAKK,IAAI;MAEvBU,CAAC,GAAGhC,EAAE,CAACqC,MAAM,CAACD,OAAO,CAAC,CACfE,IAAI,CAAC,UAACC,KAAK,EAAM;QAChB,IAAGA,KAAK,EACN,OAAOvC,EAAE,CAACwC,SAAS,CAACJ,OAAO,EAAEtB,IAAI,EAAE,KAAK,CAAC,CAC/BwB,IAAI,CAAC,UAACL,IAAI;UAAA,OAAKQ,OAAO,CAACC,OAAO,CAACT,IAAI,CAAC;QAAA,EAAC,CACrCU,KAAK,CAAC,UAACC,GAAG,EAAK;UACd,MAAO,yCAAwCA,GAAI,EAAC;QACtD,CAAC,CAAC,MAEX,MAAO,mCAAkCR,OAAQ,mBAAkB;MACvE,CAAC,CAAC;IACV,CAAC,MAEI,IAAGtB,IAAI,YAAY+B,QAAQ,EAAE;MAChCzC,GAAG,CAAC0B,OAAO,CAAC,sCAAsC,EAAEhB,IAAI,CAAC;MACzD,IAAIgC,QAAQ,GAAI,eAAc7B,KAAA,CAAKS,SAAU,IAAGqB,IAAI,CAACC,GAAG,CAAC,CAAE,EAAC;MAC5D/B,KAAA,CAAKI,iBAAiB,GAAGyB,QAAQ;MACjC,IAAIG,KAAK,GAAGnC,IAAI,CAACoC,QAAQ,CAAC,CAAC;MAC3B,IAAIC,SAAS,GAAG,EAAE;MAClB,IAAG,CAACF,KAAK,EAAE;QACTjB,CAAC,GAAGhC,EAAE,CAACwC,SAAS,CAACvB,KAAA,CAAKK,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC;MACzC,CAAC,MACI;QACH,KAAI,IAAI8B,CAAC,IAAIH,KAAK,EAAE;UAClBE,SAAS,CAACE,IAAI,CAAC,QAAQ,GAACP,QAAQ,GAAC,MAAM,CAAC;UACxC,IAAIQ,IAAI,GAAGL,KAAK,CAACG,CAAC,CAAC;UACnB,KAAI,IAAIG,CAAC,IAAID,IAAI,CAACE,OAAO,EAAE;YACzBL,SAAS,CAACE,IAAI,CAACE,CAAC,GAAG,IAAI,GAAED,IAAI,CAACE,OAAO,CAACD,CAAC,CAAC,GAAG,MAAM,CAAC;UACpD;UACAJ,SAAS,CAACE,IAAI,CAAC,MAAM,CAAC;UACtB,IAAGC,IAAI,CAAClC,qBAAqB,EAC3B+B,SAAS,CAACE,IAAI,CAACC,IAAI,CAAC,MAEpBH,SAAS,CAACE,IAAI,CAACC,IAAI,CAACG,MAAM,CAAC;QAC/B;QACArD,GAAG,CAAC0B,OAAO,CAAC,gBAAgB,EAAEqB,SAAS,CAAC;QACxCA,SAAS,CAACE,IAAI,CAAC,QAAQ,GAACP,QAAQ,GAAC,QAAQ,CAAC;QAC1Cd,CAAC,GAAG0B,mBAAmB,CAACzC,KAAA,CAAKK,IAAI,EAAE6B,SAAS,CAAC;MAC/C;IACF,CAAC,MAGI,IAAG,OAAOrC,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAAC6C,UAAU,CAAC,qBAAqB,CAAC,EAAE;MAC1EvD,GAAG,CAAC0B,OAAO,CAAC,uCAAuC,EAAEhB,IAAI,CAAC;MAE1DG,KAAA,CAAK2C,YAAY,GAAG,IAAI;MACxB3C,KAAA,CAAKK,IAAI,GAAGY,MAAM,CAACpB,IAAI,CAAC,CAAC+C,OAAO,CAAC,qBAAqB,EAAE,EAAE,CAAC;MAC3D,IAAIzB,QAAO,GAAGnB,KAAA,CAAKK,IAAI;MACvB,IAAGN,KAAK,EACN,OAAA8C,0BAAA,CAAA7C,KAAA,EAAM,KACH;QACHe,CAAC,GAAGhC,EAAE,CAAC+D,IAAI,CAAC3B,QAAO,CAAC,CACbE,IAAI,CAAC,UAACyB,IAAI,EAAM;UACf,OAAOtB,OAAO,CAACC,OAAO,CAACqB,IAAI,CAAC9B,IAAI,CAAC;QACnC,CAAC,CAAC;MACV;IACF,CAAC,MAEI,IAAG,OAAOnB,IAAI,KAAK,QAAQ,EAAE;MAChC,IAAIkD,QAAQ,GAAG,MAAM;MACrB,IAAIC,IAAI,GAAG/B,MAAM,CAACjB,KAAA,CAAKY,IAAI,CAAC;MAG5B,IAAG,gCAAgC,CAACqC,IAAI,CAACD,IAAI,CAAC,EAC5CD,QAAQ,GAAG,QAAQ,MAEnBlD,IAAI,GAAGA,IAAI,CAACqD,QAAQ,CAAC,CAAC;MAExBlD,KAAA,CAAKY,IAAI,GAAGK,MAAM,CAACjB,KAAA,CAAKY,IAAI,CAAC,CAACgC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;MACtDzD,GAAG,CAAC0B,OAAO,CAAC,oCAAoC,EAAE,QAAQ,EAAEkC,QAAQ,CAAC;MACrEhC,CAAC,GAAGhC,EAAE,CAACwC,SAAS,CAACvB,KAAA,CAAKK,IAAI,EAAER,IAAI,EAAEkD,QAAQ,CAAC,CACpC1B,IAAI,CAAC,UAACL,IAAI,EAAK;QACd,OAAOQ,OAAO,CAACC,OAAO,CAACT,IAAI,CAAC;MAC9B,CAAC,CAAC;IAEV,CAAC,MAMI,IAAGmC,KAAK,CAACC,OAAO,CAACvD,IAAI,CAAC,EAAE;MAC3BV,GAAG,CAAC0B,OAAO,CAAC,yCAAyC,EAAEhB,IAAI,CAAC;MAC5DkB,CAAC,GAAG0B,mBAAmB,CAACzC,KAAA,CAAKK,IAAI,EAAER,IAAI,CAAC;IAC1C,CAAC,MACI;MACHA,IAAI,GAAGA,IAAI,CAACqD,QAAQ,CAAC,CAAC;MACtBnC,CAAC,GAAGhC,EAAE,CAACwC,SAAS,CAACvB,KAAA,CAAKK,IAAI,EAAER,IAAI,EAAE,MAAM,CAAC,CAClCwB,IAAI,CAAC,UAACL,IAAI;QAAA,OAAKQ,OAAO,CAACC,OAAO,CAACT,IAAI,CAAC;MAAA,EAAC;IAC9C;IACAD,CAAC,IAAIA,CAAC,CAACM,IAAI,CAAC,UAACL,IAAI,EAAK;MACpBhB,KAAA,CAAKgB,IAAI,GAAGA,IAAI;MAChBhB,KAAA,CAAKqD,oBAAoB,CAAC,CAAC;IAC7B,CAAC,CAAC,CACD3B,KAAK,CAAC,UAACC,GAAG,EAAK;MACdxC,GAAG,CAACmE,KAAK,CAAC,sCAAsC,GAAEtD,KAAA,CAAKK,IAAI,EAAEsB,GAAG,CAAC;IACnE,CAAC,CAAC;IAAA,OAAA3B,KAAA;EAEJ;EAACuD,YAAA,CAAA/D,IAAA;IAAAgE,GAAA;IAAAC,GAAA,EA1ID,SAAAA,IAAA,EAAe;MACb,OAAO,IAAI,CAACpD,IAAI;IAClB;EAAC;IAAAmD,GAAA;IAAAE,KAAA,EAiJD,SAAAC,UAAUC,EAAa,EAAO;MAC5BzE,GAAG,CAAC0B,OAAO,CAAC,0BAA0B,EAAE,IAAI,CAACP,YAAY,CAAC;MAC1D,IAAG,CAAC,IAAI,CAACA,YAAY,EACnB,IAAI,CAACC,UAAU,CAAC6B,IAAI,CAACwB,EAAE,CAAC,MACrB;QACHA,EAAE,CAAC,IAAI,CAAC;MACV;MACA,OAAO,IAAI;IACb;EAAC;IAAAJ,GAAA;IAAAE,KAAA,EAED,SAAAG,cAAA,EAAgB;MACd,IAAI,CAACC,UAAU,GAAG,IAAI;IACxB;EAAC;IAAAN,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAgB;MACd,OAAO,IAAI,CAACK,UAAU,IAAI,KAAK;IACjC;EAAC;IAAAN,GAAA;IAAAE,KAAA,EAOD,SAAAxC,kBAAA,EAAoB;MAClB,OAAO,IAAI,CAACb,IAAI;IAClB;EAAC;IAAAmD,GAAA;IAAAE,KAAA,EASD,SAAAK,MAAMC,KAAa,EAAEC,GAAW,EAA+B;MAAA,IAAAC,MAAA;MAAA,IAA7BC,WAAmB,GAAAC,SAAA,CAAAtD,MAAA,QAAAsD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAC,EAAE;MACtD,IAAG,IAAI,CAAC5D,OAAO,EACb,MAAM,yBAAyB;MACjCrB,GAAG,CAAC0B,OAAO,CAAC,cAAc,EAAEmD,KAAK,EAAEC,GAAG,EAAEE,WAAW,CAAC;MAGpD,IAAIG,OAAO,GAAGlF,YAAY,GAAGsB,WAAW,CAAC,CAAC;MAC1C,IAAI6D,IAAI,GAAG,KAAK;MAChBpF,GAAG,CAACqF,KAAK,CAAC,2BAA2B,EAAEF,OAAO,CAAC;MAC/C,IAAIG,MAAM,GAAG,IAAIjF,IAAI,CAACV,WAAW,CAAC4F,IAAI,CAACJ,OAAO,CAAC,EAAE;QAAE1D,IAAI,EAAGuD;MAAY,CAAC,EAAE,IAAI,CAAC;MAC9EpF,EAAE,CAACqC,MAAM,CAAChC,YAAY,CAAC,CACtBiC,IAAI,CAAC,UAACC,KAAK,EAAK;QACf,IAAGA,KAAK,EACN,OAAOE,OAAO,CAACC,OAAO,CAAC,CAAC;QAC1B,OAAO1C,EAAE,CAAC4F,KAAK,CAACvF,YAAY,CAAC;MAC/B,CAAC,CAAC,CACDiC,IAAI,CAAC;QAAA,OAAMtC,EAAE,CAACgF,KAAK,CAACG,MAAI,CAAC7D,IAAI,EAAEiE,OAAO,EAAEN,KAAK,EAAEC,GAAG,CAAC;MAAA,EAAC,CACpD5C,IAAI,CAAC,UAACuD,IAAI,EAAK;QACdzF,GAAG,CAACqF,KAAK,CAAC,eAAe,EAAEI,IAAI,CAAC;QAChCH,MAAM,CAACpB,oBAAoB,CAAC,CAAC;QAC7BkB,IAAI,GAAG,IAAI;MACb,CAAC,CAAC,CACD7C,KAAK,CAAC,UAACC,GAAG,EAAK;QACdkD,OAAO,CAACC,IAAI,CAAC,oBAAoB,EAAEnD,GAAG,CAAC;QACvC4C,IAAI,GAAG,IAAI;MACb,CAAC,CAAC;MACFpF,GAAG,CAACqF,KAAK,CAAC,0BAA0B,CAAC;MAErC,OAAOC,MAAM;IACf;EAAC;IAAAjB,GAAA;IAAAE,KAAA,EAQD,SAAAqB,SAAShC,QAAe,EAAe;MACrC,IAAG,IAAI,CAACvC,OAAO,EACb,MAAM,yBAAyB;MACjC,OAAOzB,EAAE,CAACiG,QAAQ,CAAC,IAAI,CAAC3E,IAAI,EAAE0C,QAAQ,IAAI,MAAM,CAAC;IACnD;EAAC;IAAAS,GAAA;IAAAE,KAAA,EAOD,SAAAuB,MAAA,EAAQ;MACN,IAAG,IAAI,CAACzE,OAAO,EACb,OAAOgB,OAAO,CAAC0D,MAAM,CAAC,yBAAyB,CAAC;MAClD,IAAI,CAAC1E,OAAO,GAAG,IAAI;MACnB,OAAOzB,EAAE,CAACoG,MAAM,CAAC,IAAI,CAAC9E,IAAI,CAAC,CAACqB,KAAK,CAAC,UAACC,GAAG,EAAK;QACzCkD,OAAO,CAACC,IAAI,CAACnD,GAAG,CAAC;MACnB,CAAC,CAAC;IACJ;EAAC;IAAA6B,GAAA;IAAAE,KAAA,EAED,SAAA0B,UAAA,EAAY;MACV,IAAG,IAAI,CAAC5E,OAAO,EACb,OAAOgB,OAAO,CAAC0D,MAAM,CAAC,yBAAyB,CAAC;MAClD,IAAI,CAAC1E,OAAO,GAAG,IAAI;MACnB,IAAG,CAAC,IAAI,CAACmC,YAAY,EAAE;QACrB,OAAO5D,EAAE,CAACoG,MAAM,CAAC,IAAI,CAAC9E,IAAI,CAAC,CAACqB,KAAK,CAAC,UAACC,GAAG,EAAK;UACzCkD,OAAO,CAACC,IAAI,CAACnD,GAAG,CAAC;QACnB,CAAC,CAAC;MACJ,CAAC,MACI;QACH,OAAOH,OAAO,CAACC,OAAO,CAAC,CAAC;MAC1B;IACF;EAAC;IAAA+B,GAAA;IAAAE,KAAA,EAED,SAAAL,qBAAA,EAAuB;MACrBlE,GAAG,CAAC0B,OAAO,CAAC,qBAAqB,EAAE,IAAI,CAACN,UAAU,CAAC;MACnD,IAAI,CAACD,YAAY,GAAG,IAAI;MACxB,IAAI+E,GAAG,GAAG,IAAI,CAAC9E,UAAU;MACzB,KAAI,IAAI4B,CAAC,IAAIkD,GAAG,EAAE;QAChB,IAAG,OAAOA,GAAG,CAAClD,CAAC,CAAC,KAAK,UAAU,EAAE;UAC/BkD,GAAG,CAAClD,CAAC,CAAC,CAAC,IAAI,CAAC;QACd;MACF;MACA,OAAO,IAAI,CAAC5B,UAAU;IACxB;EAAC;IAAAiD,GAAA;IAAAE,KAAA,EAhRD,SAAA4B,WAAA,EAAoB;MAClB,OAAOvG,EAAE,CAACoG,MAAM,CAAC/F,YAAY,CAAC,CAACiC,IAAI,CAAC;QAAA,OAAMtC,EAAE,CAAC4F,KAAK,CAACvF,YAAY,CAAC;MAAA,EAAC;IACnE;EAAC;IAAAoE,GAAA;IAAAE,KAAA,EAED,SAAA6B,MAAa1F,IAAQ,EAAEC,KAAS,EAAgB;MAC9C,OAAO,IAAI0B,OAAO,CAAC,UAACC,OAAO,EAAEyD,MAAM,EAAK;QACtC,IAAI1F,IAAI,CAACK,IAAI,EAAEC,KAAK,CAAC,CAAC6D,SAAS,CAAClC,OAAO,CAAC;MAC1C,CAAC,CAAC;IACJ;EAAC;IAAA+B,GAAA;IAAAE,KAAA,EAMD,SAAA8B,OAAcC,KAAY,EAAE;MAC1B,IAAGA,KAAK,KAAK,CAAC,CAAC,EACbtG,GAAG,CAACI,OAAO,CAAC,CAAC,MAEbJ,GAAG,CAACsG,KAAK,CAACA,KAAK,CAAC;IACpB;EAAC;EAAA,OAAAjG,IAAA;AAAA,EArC+BN,WAAW;AAAA,SAAxBM,IAAI,IAAAkG,OAAA;AA0SzB,SAAShF,WAAWA,CAAA,EAAG;EACrB,OAAO,OAAO,GAAG1B,OAAO,CAAC,CAAC;AAC5B;AASA,SAASyD,mBAAmBA,CAACkD,GAAG,EAAEC,SAAS,EAAE;EAE3C,IAAI7E,CAAC,GAAGhC,EAAE,CAACwC,SAAS,CAACoE,GAAG,EAAE,EAAE,CAAC;EAC7B,IAAIE,IAAI,GAAG,EAAE;EACb,IAAI7E,IAAI,GAAG,CAAC;EACZ,KAAI,IAAImB,CAAC,IAAIyD,SAAS,EAAE;IACtB,IAAIvD,IAAI,GAAGuD,SAAS,CAACzD,CAAC,CAAC;IACvB,IAAG,CAACE,IAAI,EACN;IACF,IAAGA,IAAI,CAAClC,qBAAqB,EAAE;MAC7B0F,IAAI,CAACzD,IAAI,CAAC,CAACuD,GAAG,EAAEtD,IAAI,CAAChC,IAAI,EAAE,KAAK,CAAC,CAAC;IACpC,CAAC,MACI,IAAG,OAAOgC,IAAI,KAAK,QAAQ,EAC9BwD,IAAI,CAACzD,IAAI,CAAC,CAACuD,GAAG,EAAEtD,IAAI,EAAE,MAAM,CAAC,CAAC,MAK3B,IAAIc,KAAK,CAACC,OAAO,CAACf,IAAI,CAAC,EAC1BwD,IAAI,CAACzD,IAAI,CAAC,CAACuD,GAAG,EAAEtD,IAAI,EAAE,OAAO,CAAC,CAAC;EACnC;EAAC,IAAAyD,KAAA,YAAAA,MAAAC,EAAA,EAEkB;IACjBhF,CAAC,GAAGA,CAAC,CAACM,IAAI,CAAC,UAAS2E,OAAO,EAAC;MAC1B,IAAIC,GAAG,GAAG,IAAI;MACd,IAAGD,OAAO,EACRhF,IAAI,IAAIgF,OAAO;MACjB7G,GAAG,CAAC0B,OAAO,CAAC,kBAAkB,EAAEgF,IAAI,CAAC1D,EAAC,CAAC,EAAE6D,OAAO,CAAC;MACjD,OAAOjH,EAAE,CAACmH,UAAU,CAAAC,KAAA,CAAbpH,EAAE,EAAAqH,kBAAA,CAAeH,GAAG,EAAC;IAC9B,CAAC,CAACI,IAAI,CAACR,IAAI,CAAC1D,EAAC,CAAC,CAAC,CAAC;EAClB,CAAC;EARD,KAAI,IAAIA,EAAC,IAAI0D,IAAI;IAAAC,KAAA,CAAAC,EAAA;EAAA;EASjB,OAAOhF,CAAC,CAACM,IAAI,CAAC;IAAA,OAAMG,OAAO,CAACC,OAAO,CAACT,IAAI,CAAC;EAAA,EAAC;AAC5C"},"metadata":{},"sourceType":"module","externalDependencies":[]}