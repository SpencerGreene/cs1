{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport { NativeAppEventEmitter } from \"react-native-web/dist/index\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { AsyncStorage } from \"react-native-web/dist/index\";\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport URIUtil from \"./utils/uri\";\nimport StatefulPromise from \"./class/StatefulPromise.js\";\nimport fs from \"./fs\";\nimport getUUID from \"./utils/uuid\";\nimport base64 from 'base-64';\nimport polyfill from \"./polyfill\";\nimport _ from 'lodash';\nimport android from \"./android\";\nimport ios from \"./ios\";\nimport JSONStream from \"./json-stream\";\nvar RNFetchBlobSession = fs.RNFetchBlobSession,\n  readStream = fs.readStream,\n  createFile = fs.createFile,\n  unlink = fs.unlink,\n  exists = fs.exists,\n  mkdir = fs.mkdir,\n  session = fs.session,\n  writeStream = fs.writeStream,\n  readFile = fs.readFile,\n  ls = fs.ls,\n  isDir = fs.isDir,\n  mv = fs.mv,\n  cp = fs.cp;\nvar Blob = polyfill.Blob;\nvar emitter = DeviceEventEmitter;\nvar RNFetchBlob = NativeModules.RNFetchBlob;\nif (Platform.OS === 'ios') {\n  AppState.addEventListener('change', function (e) {\n    if (e === 'active') RNFetchBlob.emitExpiredEvent(function () {});\n  });\n}\nemitter.addListener(\"RNFetchBlobMessage\", function (e) {\n  if (e.event === 'warn') {\n    console.warn(e.detail);\n  } else if (e.event === 'error') {\n    throw e.detail;\n  } else {\n    console.log(\"RNFetchBlob native message\", e.detail);\n  }\n});\nif (!RNFetchBlob || !RNFetchBlob.fetchBlobForm || !RNFetchBlob.fetchBlob) {\n  console.warn('react-native-fetch-blob could not find valid native module.', 'please make sure you have linked native modules using `rnpm link`,', 'and restart RN packager or manually compile IOS/Android project.');\n}\nfunction wrap(path) {\n  return 'RNFetchBlob-file://' + path;\n}\nfunction config(options) {\n  return {\n    fetch: fetch.bind(options)\n  };\n}\nfunction fetchFile() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var method = arguments.length > 1 ? arguments[1] : undefined;\n  var url = arguments.length > 2 ? arguments[2] : undefined;\n  var headers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var body = arguments.length > 4 ? arguments[4] : undefined;\n  if (!URIUtil.isFileURI(url)) {\n    throw `could not fetch file from an invalid URI : ${url}`;\n  }\n  url = URIUtil.unwrapFileURI(url);\n  var promise = null;\n  var cursor = 0;\n  var total = -1;\n  var cacheData = '';\n  var info = null;\n  var _progress, _uploadProgress, _stateChange;\n  switch (method.toLowerCase()) {\n    case 'post':\n      break;\n    case 'put':\n      break;\n    default:\n      promise = fs.stat(url).then(function (stat) {\n        total = stat.size;\n        return fs.readStream(url, headers.encoding || 'utf8', Math.floor(headers.bufferSize) || 409600, Math.floor(headers.interval) || 100);\n      }).then(function (stream) {\n        return new Promise(function (resolve, reject) {\n          stream.open();\n          info = {\n            state: \"2\",\n            headers: {\n              'source': 'system-fs'\n            },\n            status: 200,\n            respType: 'text',\n            rnfbEncode: headers.encoding || 'utf8'\n          };\n          _stateChange(info);\n          stream.onData(function (chunk) {\n            _progress && _progress(cursor, total, chunk);\n            if (headers.noCache) return;\n            cacheData += chunk;\n          });\n          stream.onError(function (err) {\n            reject(err);\n          });\n          stream.onEnd(function () {\n            resolve(new FetchBlobResponse(null, info, cacheData));\n          });\n        });\n      });\n      break;\n  }\n  promise.progress = function (fn) {\n    _progress = fn;\n    return promise;\n  };\n  promise.stateChange = function (fn) {\n    _stateChange = fn;\n    return promise;\n  };\n  promise.uploadProgress = function (fn) {\n    _uploadProgress = fn;\n    return promise;\n  };\n  return promise;\n}\nfunction fetch() {\n  var taskId = getUUID();\n  var options = this || {};\n  var subscription, subscriptionUpload, stateEvent, partEvent;\n  var respInfo = {};\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var _ref = [].concat(args),\n    method = _ref[0],\n    url = _ref[1],\n    headers = _ref[2],\n    body = _ref[3];\n  headers = _.reduce(headers, function (result, value, key) {\n    result[key] = value || '';\n    return result;\n  }, {});\n  if (URIUtil.isFileURI(url)) {\n    return fetchFile(options, method, url, headers, body);\n  }\n  var promise = new Promise(function (resolve, reject) {\n    var nativeMethodName = Array.isArray(body) ? 'fetchBlobForm' : 'fetchBlob';\n    subscription = emitter.addListener('RNFetchBlobProgress', function (e) {\n      if (e.taskId === taskId && promise.onProgress) {\n        promise.onProgress(e.written, e.total, e.chunk);\n      }\n    });\n    subscriptionUpload = emitter.addListener('RNFetchBlobProgress-upload', function (e) {\n      if (e.taskId === taskId && promise.onUploadProgress) {\n        promise.onUploadProgress(e.written, e.total);\n      }\n    });\n    stateEvent = emitter.addListener('RNFetchBlobState', function (e) {\n      if (e.taskId === taskId) respInfo = e;\n      promise.onStateChange && promise.onStateChange(e);\n    });\n    subscription = emitter.addListener('RNFetchBlobExpire', function (e) {\n      if (e.taskId === taskId && promise.onExpire) {\n        promise.onExpire(e);\n      }\n    });\n    partEvent = emitter.addListener('RNFetchBlobServerPush', function (e) {\n      if (e.taskId === taskId && promise.onPartData) {\n        promise.onPartData(e.chunk);\n      }\n    });\n    if (body instanceof Blob && body.isRNFetchBlobPolyfill) {\n      body = body.getRNFetchBlobRef();\n    }\n    var req = RNFetchBlob[nativeMethodName];\n    req(options, taskId, method, url, headers || {}, body, function (err, rawType, data) {\n      subscription.remove();\n      subscriptionUpload.remove();\n      stateEvent.remove();\n      partEvent.remove();\n      delete promise['progress'];\n      delete promise['uploadProgress'];\n      delete promise['stateChange'];\n      delete promise['part'];\n      delete promise['cancel'];\n      promise.cancel = function () {};\n      if (err) reject(new Error(err, respInfo));else {\n        if (options.path || options.fileCache || options.addAndroidDownloads || options.key || options.auto && respInfo.respType === 'blob') {\n          if (options.session) session(options.session).add(data);\n        }\n        respInfo.rnfbEncode = rawType;\n        resolve(new FetchBlobResponse(taskId, respInfo, data));\n      }\n    });\n  });\n  promise.progress = function () {\n    var interval = 250;\n    var count = -1;\n    var fn = function fn() {};\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (args.length === 2) {\n      interval = args[0].interval || interval;\n      count = args[0].count || count;\n      fn = args[1];\n    } else {\n      fn = args[0];\n    }\n    promise.onProgress = fn;\n    RNFetchBlob.enableProgressReport(taskId, interval, count);\n    return promise;\n  };\n  promise.uploadProgress = function () {\n    var interval = 250;\n    var count = -1;\n    var fn = function fn() {};\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (args.length === 2) {\n      interval = args[0].interval || interval;\n      count = args[0].count || count;\n      fn = args[1];\n    } else {\n      fn = args[0];\n    }\n    promise.onUploadProgress = fn;\n    RNFetchBlob.enableUploadProgressReport(taskId, interval, count);\n    return promise;\n  };\n  promise.part = function (fn) {\n    promise.onPartData = fn;\n    return promise;\n  };\n  promise.stateChange = function (fn) {\n    promise.onStateChange = fn;\n    return promise;\n  };\n  promise.expire = function (fn) {\n    promise.onExpire = fn;\n    return promise;\n  };\n  promise.cancel = function (fn) {\n    fn = fn || function () {};\n    subscription.remove();\n    subscriptionUpload.remove();\n    stateEvent.remove();\n    RNFetchBlob.cancelRequest(taskId, fn);\n  };\n  promise.taskId = taskId;\n  return promise;\n}\nvar FetchBlobResponse = _createClass(function FetchBlobResponse(taskId, info, data) {\n  var _this = this;\n  _classCallCheck(this, FetchBlobResponse);\n  this.data = data;\n  this.taskId = taskId;\n  this.type = info.rnfbEncode;\n  this.respInfo = info;\n  this.info = function () {\n    return _this.respInfo;\n  };\n  this.array = function () {\n    var cType = info.headers['Content-Type'] || info.headers['content-type'];\n    return new Promise(function (resolve, reject) {\n      switch (_this.type) {\n        case 'base64':\n          break;\n        case 'path':\n          fs.readFile(_this.data, 'ascii').then(resolve);\n          break;\n        default:\n          break;\n      }\n    });\n  };\n  this.blob = function () {\n    var Blob = polyfill.Blob;\n    var cType = info.headers['Content-Type'] || info.headers['content-type'];\n    return new Promise(function (resolve, reject) {\n      switch (_this.type) {\n        case 'base64':\n          Blob.build(_this.data, {\n            type: cType + ';BASE64'\n          }).then(resolve);\n          break;\n        case 'path':\n          polyfill.Blob.build(wrap(_this.data), {\n            type: cType\n          }).then(resolve);\n          break;\n        default:\n          polyfill.Blob.build(_this.data, {\n            type: 'text/plain'\n          }).then(resolve);\n          break;\n      }\n    });\n  };\n  this.text = function () {\n    var res = _this.data;\n    switch (_this.type) {\n      case 'base64':\n        return base64.decode(_this.data);\n      case 'path':\n        return fs.readFile(_this.data, 'base64').then(function (b64) {\n          return Promise.resolve(base64.decode(b64));\n        });\n      default:\n        return _this.data;\n    }\n  };\n  this.json = function () {\n    switch (_this.type) {\n      case 'base64':\n        return JSON.parse(base64.decode(_this.data));\n      case 'path':\n        return fs.readFile(_this.data, 'utf8').then(function (text) {\n          return Promise.resolve(JSON.parse(text));\n        });\n      default:\n        return JSON.parse(_this.data);\n    }\n  };\n  this.base64 = function () {\n    switch (_this.type) {\n      case 'base64':\n        return _this.data;\n      case 'path':\n        return fs.readFile(_this.data, 'base64');\n      default:\n        return base64.encode(_this.data);\n    }\n  };\n  this.flush = function () {\n    var path = _this.path();\n    if (!path || _this.type !== 'path') return;\n    return unlink(path);\n  };\n  this.path = function () {\n    if (_this.type === 'path') return _this.data;\n    return null;\n  };\n  this.session = function (name) {\n    if (_this.type === 'path') return session(name).add(_this.data);else {\n      console.warn('only file paths can be add into session.');\n      return null;\n    }\n  };\n  this.readStream = function (encode) {\n    if (_this.type === 'path') {\n      return readStream(_this.data, encode);\n    } else {\n      console.warn('RNFetchblob', 'this response data does not contains any available stream');\n      return null;\n    }\n  };\n  this.readFile = function (encode) {\n    if (_this.type === 'path') {\n      encode = encode || 'utf8';\n      return readFile(_this.data, encode);\n    } else {\n      console.warn('RNFetchblob', 'this response does not contains a readable file');\n      return null;\n    }\n  };\n});\nexport default {\n  fetch: fetch,\n  base64: base64,\n  android: android,\n  ios: ios,\n  config: config,\n  session: session,\n  fs: fs,\n  wrap: wrap,\n  polyfill: polyfill,\n  JSONStream: JSONStream\n};","map":{"version":3,"names":["NativeAppEventEmitter","Platform","AsyncStorage","AppState","URIUtil","StatefulPromise","fs","getUUID","base64","polyfill","_","android","ios","JSONStream","RNFetchBlobSession","readStream","createFile","unlink","exists","mkdir","session","writeStream","readFile","ls","isDir","mv","cp","Blob","emitter","DeviceEventEmitter","RNFetchBlob","NativeModules","OS","addEventListener","e","emitExpiredEvent","addListener","event","console","warn","detail","log","fetchBlobForm","fetchBlob","wrap","path","config","options","fetch","bind","fetchFile","arguments","length","undefined","method","url","headers","body","isFileURI","unwrapFileURI","promise","cursor","total","cacheData","info","_progress","_uploadProgress","_stateChange","toLowerCase","stat","then","size","encoding","Math","floor","bufferSize","interval","stream","Promise","resolve","reject","open","state","status","respType","rnfbEncode","onData","chunk","noCache","onError","err","onEnd","FetchBlobResponse","progress","fn","stateChange","uploadProgress","taskId","subscription","subscriptionUpload","stateEvent","partEvent","respInfo","_len","args","Array","_key","_ref","concat","reduce","result","value","key","nativeMethodName","isArray","onProgress","written","onUploadProgress","onStateChange","onExpire","onPartData","isRNFetchBlobPolyfill","getRNFetchBlobRef","req","rawType","data","remove","cancel","Error","fileCache","addAndroidDownloads","auto","add","count","_len2","_key2","enableProgressReport","_len3","_key3","enableUploadProgressReport","part","expire","cancelRequest","_createClass","_this","_classCallCheck","type","array","cType","blob","build","text","res","decode","b64","json","JSON","parse","encode","flush","name"],"sources":["/Users/sgreene/src/cs1/node_modules/react-native-fetch-blob/index.js"],"sourcesContent":["// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n  Platform,\n  AsyncStorage,\n  AppState,\n} from 'react-native'\nimport type {\n  RNFetchBlobNative,\n  RNFetchBlobConfig,\n  RNFetchBlobStream,\n  RNFetchBlobResponseInfo\n} from './types'\nimport URIUtil from './utils/uri'\nimport StatefulPromise from './class/StatefulPromise.js'\nimport fs from './fs'\nimport getUUID from './utils/uuid'\nimport base64 from 'base-64'\nimport polyfill from './polyfill'\nimport _ from 'lodash'\nimport android from './android'\nimport ios from './ios'\nimport JSONStream from './json-stream'\nconst {\n  RNFetchBlobSession,\n  readStream,\n  createFile,\n  unlink,\n  exists,\n  mkdir,\n  session,\n  writeStream,\n  readFile,\n  ls,\n  isDir,\n  mv,\n  cp\n} = fs\n\nconst Blob = polyfill.Blob\nconst emitter = DeviceEventEmitter\nconst RNFetchBlob = NativeModules.RNFetchBlob\n\n// when app resumes, check if there's any expired network task and trigger\n// their .expire event\nif(Platform.OS === 'ios') {\n  AppState.addEventListener('change', (e) => {\n    if(e === 'active')\n      RNFetchBlob.emitExpiredEvent(()=>{})\n  })\n}\n\n// register message channel event handler.\nemitter.addListener(\"RNFetchBlobMessage\", (e) => {\n\n  if(e.event === 'warn') {\n    console.warn(e.detail)\n  }\n  else if (e.event === 'error') {\n    throw e.detail\n  }\n  else {\n    console.log(\"RNFetchBlob native message\", e.detail)\n  }\n})\n\n// Show warning if native module not detected\nif(!RNFetchBlob || !RNFetchBlob.fetchBlobForm || !RNFetchBlob.fetchBlob) {\n  console.warn(\n    'react-native-fetch-blob could not find valid native module.',\n    'please make sure you have linked native modules using `rnpm link`,',\n    'and restart RN packager or manually compile IOS/Android project.'\n  )\n}\n\nfunction wrap(path:string):string {\n  return 'RNFetchBlob-file://' + path\n}\n\n/**\n * Calling this method will inject configurations into followed `fetch` method.\n * @param  {RNFetchBlobConfig} options\n *         Fetch API configurations, contains the following options :\n *         @property {boolean} fileCache\n *                   When fileCache is `true`, response data will be saved in\n *                   storage with a random generated file name, rather than\n *                   a BASE64 encoded string.\n *         @property {string} appendExt\n *                   Set this property to change file extension of random-\n *                   generated file name.\n *         @property {string} path\n *                   If this property has a valid string format, resonse data\n *                   will be saved to specific file path. Default string format\n *                   is : `RNFetchBlob-file://path-to-file`\n *         @property {string} key\n *                   If this property is set, it will be converted to md5, to\n *                   check if a file with this name exists.\n *                   If it exists, the absolute path is returned (no network\n *                   activity takes place )\n *                   If it doesn't exist, the file is downloaded as usual\n *         @property {number} timeout\n *                   Request timeout in millionseconds, by default it's 30000ms.\n *\n * @return {function} This method returns a `fetch` method instance.\n */\nfunction config (options:RNFetchBlobConfig) {\n  return { fetch : fetch.bind(options) }\n}\n\n/**\n * Fetch from file system, use the same interface as RNFB.fetch\n * @param  {RNFetchBlobConfig} [options={}] Fetch configurations\n * @param  {string} method     Should be one of `get`, `post`, `put`\n * @param  {string} url        A file URI string\n * @param  {string} headers    Arguments of file system API\n * @param  {any} body       Data to put or post to file systen.\n * @return {Promise}\n */\nfunction fetchFile(options = {}, method, url, headers = {}, body):Promise {\n\n  if(!URIUtil.isFileURI(url)) {\n    throw `could not fetch file from an invalid URI : ${url}`\n  }\n\n  url = URIUtil.unwrapFileURI(url)\n\n  let promise = null\n  let cursor = 0\n  let total = -1\n  let cacheData = ''\n  let info = null\n  let _progress, _uploadProgress, _stateChange\n\n  switch(method.toLowerCase()) {\n\n    case 'post':\n    break\n\n    case 'put':\n    break\n\n    // read data from file system\n    default:\n      promise = fs.stat(url)\n      .then((stat) => {\n        total = stat.size\n        return fs.readStream(url,\n          headers.encoding || 'utf8',\n          Math.floor(headers.bufferSize) || 409600,\n          Math.floor(headers.interval) || 100\n        )\n      })\n      .then((stream) => new Promise((resolve, reject) => {\n        stream.open()\n        info = {\n          state : \"2\",\n          headers : { 'source' : 'system-fs' },\n          status : 200,\n          respType : 'text',\n          rnfbEncode : headers.encoding || 'utf8'\n        }\n        _stateChange(info)\n        stream.onData((chunk) => {\n          _progress && _progress(cursor, total, chunk)\n          if(headers.noCache)\n            return\n          cacheData += chunk\n        })\n        stream.onError((err) => { reject(err) })\n        stream.onEnd(() => {\n          resolve(new FetchBlobResponse(null, info, cacheData))\n        })\n      }))\n    break\n  }\n\n  promise.progress = (fn) => {\n    _progress = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    _stateChange = fn\n    return promise\n  }\n  promise.uploadProgress = (fn) => {\n    _uploadProgress = fn\n    return promise\n  }\n\n  return promise\n}\n\n/**\n * Create a HTTP request by settings, the `this` context is a `RNFetchBlobConfig` object.\n * @param  {string} method HTTP method, should be `GET`, `POST`, `PUT`, `DELETE`\n * @param  {string} url Request target url string.\n * @param  {object} headers HTTP request headers.\n * @param  {string} body\n *         Request body, can be either a BASE64 encoded data string,\n *         or a file path with prefix `RNFetchBlob-file://` (can be changed)\n * @return {Promise}\n *         This promise instance also contains a Customized method `progress`for\n *         register progress event handler.\n */\nfunction fetch(...args:any):Promise {\n\n  // create task ID for receiving progress event\n  let taskId = getUUID()\n  let options = this || {}\n  let subscription, subscriptionUpload, stateEvent, partEvent\n  let respInfo = {}\n  let [method, url, headers, body] = [...args]\n\n  // # 241 normalize null or undefined headers, in case nil or null string\n  // pass to native context\n  headers = _.reduce(headers, (result, value, key) => {\n    result[key] = value || ''\n    return result\n  }, {});\n\n  // fetch from file system\n  if(URIUtil.isFileURI(url)) {\n    return fetchFile(options, method, url, headers, body)\n  }\n\n  // from remote HTTP(S)\n  let promise = new Promise((resolve, reject) => {\n    let nativeMethodName = Array.isArray(body) ? 'fetchBlobForm' : 'fetchBlob'\n\n    // on progress event listener\n    subscription = emitter.addListener('RNFetchBlobProgress', (e) => {\n      if(e.taskId === taskId && promise.onProgress) {\n        promise.onProgress(e.written, e.total, e.chunk)\n      }\n    })\n\n    subscriptionUpload = emitter.addListener('RNFetchBlobProgress-upload', (e) => {\n      if(e.taskId === taskId && promise.onUploadProgress) {\n        promise.onUploadProgress(e.written, e.total)\n      }\n    })\n\n    stateEvent = emitter.addListener('RNFetchBlobState', (e) => {\n      if(e.taskId === taskId)\n        respInfo = e\n      promise.onStateChange && promise.onStateChange(e)\n    })\n\n    subscription = emitter.addListener('RNFetchBlobExpire', (e) => {\n      if(e.taskId === taskId && promise.onExpire) {\n        promise.onExpire(e)\n      }\n    })\n\n    partEvent = emitter.addListener('RNFetchBlobServerPush', (e) => {\n      if(e.taskId === taskId && promise.onPartData) {\n        promise.onPartData(e.chunk)\n      }\n    })\n\n    // When the request body comes from Blob polyfill, we should use special its ref\n    // as the request body\n    if( body instanceof Blob && body.isRNFetchBlobPolyfill) {\n      body = body.getRNFetchBlobRef()\n    }\n\n    let req = RNFetchBlob[nativeMethodName]\n\n    /**\n     * Send request via native module, the response callback accepts three arguments\n     * @callback\n     * @param err {any} Error message or object, when the request success, this\n     *                  parameter should be `null`.\n     * @param rawType { 'utf8' | 'base64' | 'path'} RNFB request will be stored\n     *                  as UTF8 string, BASE64 string, or a file path reference\n     *                  in JS context, and this parameter indicates which one\n     *                  dose the response data presents.\n     * @param data {string} Response data or its reference.\n     */\n    req(options, taskId, method, url, headers || {}, body, (err, rawType, data) => {\n\n      // task done, remove event listeners\n      subscription.remove()\n      subscriptionUpload.remove()\n      stateEvent.remove()\n      partEvent.remove()\n      delete promise['progress']\n      delete promise['uploadProgress']\n      delete promise['stateChange']\n      delete promise['part']\n      delete promise['cancel']\n      // delete promise['expire']\n      promise.cancel = () => {}\n\n      if(err)\n        reject(new Error(err, respInfo))\n      else {\n        // response data is saved to storage, create a session for it\n        if(options.path || options.fileCache || options.addAndroidDownloads\n          || options.key || options.auto && respInfo.respType === 'blob') {\n          if(options.session)\n            session(options.session).add(data)\n        }\n        respInfo.rnfbEncode = rawType\n        resolve(new FetchBlobResponse(taskId, respInfo, data))\n      }\n\n    })\n\n  })\n\n  // extend Promise object, add `progress`, `uploadProgress`, and `cancel`\n  // method for register progress event handler and cancel request.\n  // Add second parameter for performance purpose #140\n  // When there's only one argument pass to this method, use default `interval`\n  // and `count`, otherwise use the given on.\n  // TODO : code refactor, move `uploadProgress` and `progress` to StatefulPromise\n  promise.progress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onProgress = fn\n    RNFetchBlob.enableProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.uploadProgress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onUploadProgress = fn\n    RNFetchBlob.enableUploadProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.part = (fn) => {\n    promise.onPartData = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    promise.onStateChange = fn\n    return promise\n  }\n  promise.expire = (fn) => {\n    promise.onExpire = fn\n    return promise\n  }\n  promise.cancel = (fn) => {\n    fn = fn || function(){}\n    subscription.remove()\n    subscriptionUpload.remove()\n    stateEvent.remove()\n    RNFetchBlob.cancelRequest(taskId, fn)\n  }\n  promise.taskId = taskId\n\n  return promise\n\n}\n\n/**\n * RNFetchBlob response object class.\n */\nclass FetchBlobResponse {\n\n  taskId : string;\n  path : () => string | null;\n  type : 'base64' | 'path' | 'utf8';\n  data : any;\n  blob : (contentType:string, sliceSize:number) => Promise<Blob>;\n  text : () => string | Promise<any>;\n  json : () => any;\n  base64 : () => any;\n  flush : () => void;\n  respInfo : RNFetchBlobResponseInfo;\n  session : (name:string) => RNFetchBlobSession | null;\n  readFile : (encode: 'base64' | 'utf8' | 'ascii') => ?Promise<any>;\n  readStream : (\n    encode: 'utf8' | 'ascii' | 'base64',\n  ) => RNFetchBlobStream | null;\n\n  constructor(taskId:string, info:RNFetchBlobResponseInfo, data:any) {\n    this.data = data\n    this.taskId = taskId\n    this.type = info.rnfbEncode\n    this.respInfo = info\n\n    this.info = ():RNFetchBlobResponseInfo => {\n      return this.respInfo\n    }\n\n    this.array = ():Promise<Array> => {\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            // TODO : base64 to array buffer\n          break\n          case 'path':\n            fs.readFile(this.data, 'ascii').then(resolve)\n          break\n          default:\n            // TODO : text to array buffer\n          break\n        }\n      })\n    }\n\n    /**\n     * Convert result to javascript RNFetchBlob object.\n     * @return {Promise<Blob>} Return a promise resolves Blob object.\n     */\n    this.blob = ():Promise<Blob> => {\n      let Blob = polyfill.Blob\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            Blob.build(this.data, { type : cType + ';BASE64' }).then(resolve)\n          break\n          case 'path':\n            polyfill.Blob.build(wrap(this.data), { type : cType }).then(resolve)\n          break\n          default:\n            polyfill.Blob.build(this.data, { type : 'text/plain' }).then(resolve)\n          break\n        }\n      })\n    }\n    /**\n     * Convert result to text.\n     * @return {string} Decoded base64 string.\n     */\n    this.text = ():string | Promise<any> => {\n      let res = this.data\n      switch(this.type) {\n        case 'base64':\n          return base64.decode(this.data)\n        case 'path':\n          return fs.readFile(this.data, 'base64').then((b64) => Promise.resolve(base64.decode(b64)))\n        default:\n          return this.data\n      }\n    }\n    /**\n     * Convert result to JSON object.\n     * @return {object} Parsed javascript object.\n     */\n    this.json = ():any => {\n      switch(this.type) {\n        case 'base64':\n          return JSON.parse(base64.decode(this.data))\n        case 'path':\n          return fs.readFile(this.data, 'utf8')\n                   .then((text) => Promise.resolve(JSON.parse(text)))\n        default:\n          return JSON.parse(this.data)\n      }\n    }\n    /**\n     * Return BASE64 string directly.\n     * @return {string} BASE64 string of response body.\n     */\n    this.base64 = ():string | Promise<any> => {\n      switch(this.type) {\n        case 'base64':\n          return this.data\n        case 'path':\n          return fs.readFile(this.data, 'base64')\n        default:\n          return base64.encode(this.data)\n      }\n    }\n    /**\n     * Remove cahced file\n     * @return {Promise}\n     */\n    this.flush = () => {\n      let path = this.path()\n      if(!path || this.type !== 'path')\n        return\n      return unlink(path)\n    }\n    /**\n     * get path of response temp file\n     * @return {string} File path of temp file.\n     */\n    this.path = () => {\n      if(this.type === 'path')\n        return this.data\n      return null\n    }\n\n    this.session = (name:string):RNFetchBlobSession | null => {\n      if(this.type === 'path')\n        return session(name).add(this.data)\n      else {\n        console.warn('only file paths can be add into session.')\n        return null\n      }\n    }\n    /**\n     * Start read stream from cached file\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @param  {Function} fn On data event handler\n     * @return {void}\n     */\n    this.readStream = (encode: 'base64' | 'utf8' | 'ascii'):RNFetchBlobStream | null => {\n      if(this.type === 'path') {\n        return readStream(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response data does not contains any available stream')\n        return null\n      }\n    }\n    /**\n     * Read file content with given encoding, if the response does not contains\n     * a file path, show warning message\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @return {String}\n     */\n    this.readFile = (encode: 'base64' | 'utf8' | 'ascii') => {\n      if(this.type === 'path') {\n        encode = encode || 'utf8'\n        return readFile(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response does not contains a readable file')\n        return null\n      }\n    }\n  }\n\n}\n\nexport default {\n  fetch,\n  base64,\n  android,\n  ios,\n  config,\n  session,\n  fs,\n  wrap,\n  polyfill,\n  JSONStream\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}