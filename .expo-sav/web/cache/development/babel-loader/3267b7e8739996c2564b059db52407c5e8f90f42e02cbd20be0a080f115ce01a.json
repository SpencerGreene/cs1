{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport RNFetchBlob from \"../index.js\";\nimport XMLHttpRequestEventTarget from \"./XMLHttpRequestEventTarget.js\";\nimport Log from \"../utils/log.js\";\nimport Blob from \"./Blob.js\";\nimport ProgressEvent from \"./ProgressEvent.js\";\nimport URIUtil from \"../utils/uri\";\nvar log = new Log('XMLHttpRequest');\nlog.disable();\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\nvar XMLHttpRequest = function (_XMLHttpRequestEventT) {\n  _inherits(XMLHttpRequest, _XMLHttpRequestEventT);\n  var _super = _createSuper(XMLHttpRequest);\n  function XMLHttpRequest() {\n    var _this;\n    _classCallCheck(this, XMLHttpRequest);\n    log.verbose('XMLHttpRequest constructor called');\n    _this = _super.call(this);\n    _this.upload = new XMLHttpRequestEventTarget();\n    _this._readyState = UNSENT;\n    _this._uriType = 'net';\n    _this._response = '';\n    _this._responseText = '';\n    _this._responseHeaders = {};\n    _this._responseType = '';\n    _this._responseURL = '';\n    _this._responseXML = '';\n    _this._status = 0;\n    _this._statusText = '';\n    _this._timeout = 60000;\n    _this._sendFlag = false;\n    _this._uploadStarted = false;\n    _this._increment = false;\n    _this._config = {};\n    _this._headers = {\n      'Content-Type': 'text/plain'\n    };\n    _this._cleanUp = null;\n    _this._headerReceived = function (e) {\n      log.debug('header received ', _this._task.taskId, e);\n      _this.responseURL = _this._url;\n      if (e.state === \"2\" && e.taskId === _this._task.taskId) {\n        _this._responseHeaders = e.headers;\n        _this._statusText = e.status;\n        _this._status = Math.floor(e.status);\n        _this._dispatchReadStateChange(XMLHttpRequest.HEADERS_RECEIVED);\n      }\n    };\n    _this._uploadProgressEvent = function (send, total) {\n      if (!_this._uploadStarted) {\n        _this.upload.dispatchEvent('loadstart');\n        _this._uploadStarted = true;\n      }\n      if (send >= total) _this.upload.dispatchEvent('load');\n      _this.upload.dispatchEvent('progress', new ProgressEvent(true, send, total));\n    };\n    _this._progressEvent = function (send, total, chunk) {\n      log.verbose(_this.readyState);\n      if (_this._readyState === XMLHttpRequest.HEADERS_RECEIVED) _this._dispatchReadStateChange(XMLHttpRequest.LOADING);\n      var lengthComputable = false;\n      if (total && total >= 0) lengthComputable = true;\n      var e = new ProgressEvent(lengthComputable, send, total);\n      if (_this._increment) {\n        _this._responseText += chunk;\n      }\n      _this.dispatchEvent('progress', e);\n    };\n    _this._onError = function (err) {\n      var statusCode = Math.floor(_this.status);\n      if (statusCode >= 100 && statusCode !== 408) {\n        return;\n      }\n      log.debug('XMLHttpRequest error', err);\n      _this._statusText = err;\n      _this._status = String(err).match(/\\d+/);\n      _this._status = _this._status ? Math.floor(_this.status) : 404;\n      _this._dispatchReadStateChange(XMLHttpRequest.DONE);\n      if (err && String(err.message).match(/(timed\\sout|timedout)/) || _this._status == 408) {\n        _this.dispatchEvent('timeout');\n      }\n      _this.dispatchEvent('loadend');\n      _this.dispatchEvent('error', {\n        type: 'error',\n        detail: err\n      });\n      _this.clearEventListeners();\n    };\n    _this._onDone = function (resp) {\n      log.debug('XMLHttpRequest done', _this._url, resp, _assertThisInitialized(_this));\n      _this._statusText = _this._status;\n      var responseDataReady = function responseDataReady() {\n        log.debug('request done state = 4');\n        _this.dispatchEvent('load');\n        _this.dispatchEvent('loadend');\n        _this._dispatchReadStateChange(XMLHttpRequest.DONE);\n        _this.clearEventListeners();\n      };\n      if (resp) {\n        var info = resp.respInfo || {};\n        log.debug(_this._url, info, info.respType);\n        switch (_this._responseType) {\n          case 'blob':\n            resp.blob().then(function (b) {\n              _this._responseText = resp.text();\n              _this._response = b;\n              responseDataReady();\n            });\n            break;\n          case 'arraybuffer':\n            break;\n          case 'json':\n            _this._response = resp.json();\n            _this._responseText = resp.text();\n            break;\n          default:\n            _this._responseText = resp.text();\n            _this._response = _this.responseText;\n            responseDataReady();\n            break;\n        }\n      }\n    };\n    return _this;\n  }\n  _createClass(XMLHttpRequest, [{\n    key: \"UNSENT\",\n    get: function get() {\n      return UNSENT;\n    }\n  }, {\n    key: \"OPENED\",\n    get: function get() {\n      return OPENED;\n    }\n  }, {\n    key: \"HEADERS_RECEIVED\",\n    get: function get() {\n      return HEADERS_RECEIVED;\n    }\n  }, {\n    key: \"LOADING\",\n    get: function get() {\n      return LOADING;\n    }\n  }, {\n    key: \"DONE\",\n    get: function get() {\n      return DONE;\n    }\n  }, {\n    key: \"open\",\n    value: function open(method, url, async, user, password) {\n      log.verbose('XMLHttpRequest open ', method, url, async, user, password);\n      this._method = method;\n      this._url = url;\n      this._headers = {};\n      this._increment = URIUtil.isJSONStreamURI(this._url);\n      this._url = this._url.replace(/^JSONStream\\:\\/\\//, '');\n      this._dispatchReadStateChange(XMLHttpRequest.OPENED);\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this2 = this;\n      this._body = body;\n      if (this._readyState !== XMLHttpRequest.OPENED) throw 'InvalidStateError : XMLHttpRequest is not opened yet.';\n      var promise = Promise.resolve();\n      this._sendFlag = true;\n      log.verbose('XMLHttpRequest send ', body);\n      var _method = this._method,\n        _url = this._url,\n        _headers = this._headers;\n      log.verbose('sending request with args', _method, _url, _headers, body);\n      log.verbose(typeof body, body instanceof FormData);\n      if (body instanceof Blob) {\n        log.debug('sending blob body', body._blobCreated);\n        promise = new Promise(function (resolve, reject) {\n          body.onCreated(function (blob) {\n            if (blob.isDerived) {\n              _this2._cleanUp = function () {\n                blob.close();\n              };\n            }\n            log.debug('body created send request');\n            body = RNFetchBlob.wrap(blob.getRNFetchBlobRef());\n            resolve();\n          });\n        });\n      } else if (typeof body === 'object') {\n        body = JSON.stringify(body);\n        promise = Promise.resolve();\n      } else {\n        body = body ? body.toString() : body;\n        promise = Promise.resolve();\n      }\n      promise.then(function () {\n        log.debug('send request invoke', body);\n        for (var h in _headers) {\n          _headers[h] = _headers[h].toString();\n        }\n        _this2._task = RNFetchBlob.config({\n          auto: true,\n          timeout: _this2._timeout,\n          increment: _this2._increment,\n          binaryContentTypes: XMLHttpRequest.binaryContentTypes\n        }).fetch(_method, _url, _headers, body);\n        _this2._task.stateChange(_this2._headerReceived).uploadProgress(_this2._uploadProgressEvent).progress(_this2._progressEvent).catch(_this2._onError).then(_this2._onDone);\n      });\n    }\n  }, {\n    key: \"overrideMimeType\",\n    value: function overrideMimeType(mime) {\n      log.verbose('XMLHttpRequest overrideMimeType', mime);\n      this._headers['Content-Type'] = mime;\n    }\n  }, {\n    key: \"setRequestHeader\",\n    value: function setRequestHeader(name, value) {\n      log.verbose('XMLHttpRequest set header', name, value);\n      if (this._readyState !== OPENED || this._sendFlag) {\n        throw `InvalidStateError : Calling setRequestHeader in wrong state  ${this._readyState}`;\n      }\n      if (typeof name !== 'string' || /[^\\u0000-\\u00ff]/.test(name)) {\n        throw 'TypeError : header field name should be a string';\n      }\n      var invalidPatterns = [/[\\(\\)\\>\\<\\@\\,\\:\\\\\\/\\[\\]\\?\\=\\}\\{\\s\\ \\u007f\\;\\t\\0\\v\\r]/, /tt/];\n      for (var i in invalidPatterns) {\n        if (invalidPatterns[i].test(name) || typeof name !== 'string') {\n          throw `SyntaxError : Invalid header field name ${name}`;\n        }\n      }\n      this._headers[name] = value;\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      var _this3 = this;\n      log.verbose('XMLHttpRequest abort ');\n      if (!this._task) return;\n      this._task.cancel(function (err) {\n        var e = {\n          timeStamp: Date.now()\n        };\n        if (_this3.onabort) _this3.onabort();\n        if (err) {\n          e.detail = err;\n          e.type = 'error';\n          _this3.dispatchEvent('error', e);\n        } else {\n          e.type = 'abort';\n          _this3.dispatchEvent('abort', e);\n        }\n      });\n    }\n  }, {\n    key: \"getResponseHeader\",\n    value: function getResponseHeader(field) {\n      log.verbose('XMLHttpRequest get header', field, this._responseHeaders);\n      if (!this._responseHeaders) return null;\n      return this._responseHeaders[field] || this._responseHeaders[field.toLowerCase()] || null;\n    }\n  }, {\n    key: \"getAllResponseHeaders\",\n    value: function getAllResponseHeaders() {\n      log.verbose('XMLHttpRequest get all headers', this._responseHeaders);\n      if (!this._responseHeaders) return '';\n      var result = '';\n      var respHeaders = this.responseHeaders;\n      for (var i in respHeaders) {\n        result += `${i}: ${respHeaders[i]}${String.fromCharCode(0x0D, 0x0A)}`;\n      }\n      return result.substr(0, result.length - 2);\n    }\n  }, {\n    key: \"_dispatchReadStateChange\",\n    value: function _dispatchReadStateChange(state) {\n      this._readyState = state;\n      if (typeof this._onreadystatechange === 'function') this._onreadystatechange();\n    }\n  }, {\n    key: \"onreadystatechange\",\n    get: function get() {\n      return this._onreadystatechange;\n    },\n    set: function set(fn) {\n      log.verbose('XMLHttpRequest set onreadystatechange', fn);\n      this._onreadystatechange = fn;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      log.verbose('get readyState', this._readyState);\n      return this._readyState;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      log.verbose('get status', this._status);\n      return this._status;\n    }\n  }, {\n    key: \"statusText\",\n    get: function get() {\n      log.verbose('get statusText', this._statusText);\n      return this._statusText;\n    }\n  }, {\n    key: \"response\",\n    get: function get() {\n      log.verbose('get response', this._response);\n      return this._response;\n    }\n  }, {\n    key: \"responseText\",\n    get: function get() {\n      log.verbose('get responseText', this._responseText);\n      return this._responseText;\n    }\n  }, {\n    key: \"responseURL\",\n    get: function get() {\n      log.verbose('get responseURL', this._responseURL);\n      return this._responseURL;\n    }\n  }, {\n    key: \"responseHeaders\",\n    get: function get() {\n      log.verbose('get responseHeaders', this._responseHeaders);\n      return this._responseHeaders;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      log.verbose('get timeout', this._timeout);\n      return this._timeout;\n    },\n    set: function set(val) {\n      this._timeout = val * 1000;\n      log.verbose('set timeout', this._timeout);\n    }\n  }, {\n    key: \"responseType\",\n    get: function get() {\n      log.verbose('get response type', this._responseType);\n      return this._responseType;\n    },\n    set: function set(val) {\n      log.verbose('set response type', this._responseType);\n      this._responseType = val;\n    }\n  }], [{\n    key: \"UNSENT\",\n    get: function get() {\n      return UNSENT;\n    }\n  }, {\n    key: \"OPENED\",\n    get: function get() {\n      return OPENED;\n    }\n  }, {\n    key: \"HEADERS_RECEIVED\",\n    get: function get() {\n      return HEADERS_RECEIVED;\n    }\n  }, {\n    key: \"LOADING\",\n    get: function get() {\n      return LOADING;\n    }\n  }, {\n    key: \"DONE\",\n    get: function get() {\n      return DONE;\n    }\n  }, {\n    key: \"setLog\",\n    value: function setLog(level) {\n      if (level === -1) log.disable();else log.level(level);\n    }\n  }, {\n    key: \"addBinaryContentType\",\n    value: function addBinaryContentType(substr) {\n      for (var i in XMLHttpRequest.binaryContentTypes) {\n        if (new RegExp(substr, 'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n          return;\n        }\n      }\n      XMLHttpRequest.binaryContentTypes.push(substr);\n    }\n  }, {\n    key: \"removeBinaryContentType\",\n    value: function removeBinaryContentType(val) {\n      for (var i in XMLHttpRequest.binaryContentTypes) {\n        if (new RegExp(substr, 'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n          XMLHttpRequest.binaryContentTypes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"isRNFBPolyfill\",\n    get: function get() {\n      return true;\n    }\n  }]);\n  return XMLHttpRequest;\n}(XMLHttpRequestEventTarget);\nXMLHttpRequest.binaryContentTypes = ['image/', 'video/', 'audio/'];\nexport { XMLHttpRequest as default };","map":{"version":3,"names":["RNFetchBlob","XMLHttpRequestEventTarget","Log","Blob","ProgressEvent","URIUtil","log","disable","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","XMLHttpRequest","_XMLHttpRequestEventT","_inherits","_super","_createSuper","_this","_classCallCheck","verbose","call","upload","_readyState","_uriType","_response","_responseText","_responseHeaders","_responseType","_responseURL","_responseXML","_status","_statusText","_timeout","_sendFlag","_uploadStarted","_increment","_config","_headers","_cleanUp","_headerReceived","e","debug","_task","taskId","responseURL","_url","state","headers","status","Math","floor","_dispatchReadStateChange","_uploadProgressEvent","send","total","dispatchEvent","_progressEvent","chunk","readyState","lengthComputable","_onError","err","statusCode","String","match","message","type","detail","clearEventListeners","_onDone","resp","_assertThisInitialized","responseDataReady","info","respInfo","respType","blob","then","b","text","json","responseText","_createClass","key","get","value","open","method","url","async","user","password","_method","isJSONStreamURI","replace","body","_this2","_body","promise","Promise","resolve","FormData","_blobCreated","reject","onCreated","isDerived","close","wrap","getRNFetchBlobRef","JSON","stringify","toString","h","config","auto","timeout","increment","binaryContentTypes","fetch","stateChange","uploadProgress","progress","catch","overrideMimeType","mime","setRequestHeader","name","test","invalidPatterns","i","abort","_this3","cancel","timeStamp","Date","now","onabort","getResponseHeader","field","toLowerCase","getAllResponseHeaders","result","respHeaders","responseHeaders","fromCharCode","substr","length","_onreadystatechange","set","fn","val","setLog","level","addBinaryContentType","RegExp","push","removeBinaryContentType","splice","default"],"sources":["/Users/sgreene/src/cs1/node_modules/react-native-fetch-blob/polyfill/XMLHttpRequest.js"],"sourcesContent":["// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport XMLHttpRequestEventTarget from './XMLHttpRequestEventTarget.js'\nimport Log from '../utils/log.js'\nimport Blob from './Blob.js'\nimport ProgressEvent from './ProgressEvent.js'\nimport URIUtil from '../utils/uri'\n\nconst log = new Log('XMLHttpRequest')\n\nlog.disable()\n// log.level(3)\n\nconst UNSENT = 0\nconst OPENED = 1\nconst HEADERS_RECEIVED = 2\nconst LOADING = 3\nconst DONE = 4\n\nexport default class XMLHttpRequest extends XMLHttpRequestEventTarget{\n\n  _onreadystatechange : () => void;\n\n  upload : XMLHttpRequestEventTarget = new XMLHttpRequestEventTarget();\n  static binaryContentTypes : Array<string> = [\n    'image/', 'video/', 'audio/'\n  ];\n\n  // readonly\n  _readyState : number = UNSENT;\n  _uriType : 'net' | 'file' = 'net';\n  _response : any = '';\n  _responseText : any = '';\n  _responseHeaders : any = {};\n  _responseType : '' | 'arraybuffer' | 'blob'  | 'json' | 'text' = '';\n  // TODO : not suppoted ATM\n  _responseURL : null = '';\n  _responseXML : null = '';\n  _status : number = 0;\n  _statusText : string = '';\n  _timeout : number = 60000;\n  _sendFlag : boolean = false;\n  _uploadStarted : boolean = false;\n  _increment : boolean = false;\n\n  // RNFetchBlob compatible data structure\n  _config : RNFetchBlobConfig = {};\n  _url : any;\n  _method : string;\n  _headers: any = {\n    'Content-Type' : 'text/plain'\n  };\n  _cleanUp : () => void = null;\n  _body: any;\n\n  // RNFetchBlob promise object, which has `progress`, `uploadProgress`, and\n  // `cancel` methods.\n  _task: any;\n\n  // constants\n  get UNSENT() { return UNSENT }\n  get OPENED() { return OPENED }\n  get HEADERS_RECEIVED() { return HEADERS_RECEIVED }\n  get LOADING() { return LOADING }\n  get DONE() { return DONE }\n\n  static get UNSENT() {\n    return UNSENT\n  }\n\n  static get OPENED() {\n    return OPENED\n  }\n\n  static get HEADERS_RECEIVED() {\n    return HEADERS_RECEIVED\n  }\n\n  static get LOADING() {\n    return LOADING\n  }\n\n  static get DONE() {\n    return DONE\n  }\n\n  static setLog(level:number) {\n    if(level === -1)\n      log.disable()\n    else\n      log.level(level)\n  }\n\n  static addBinaryContentType(substr:string) {\n    for(let i in XMLHttpRequest.binaryContentTypes) {\n      if(new RegExp(substr,'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n        return\n      }\n    }\n    XMLHttpRequest.binaryContentTypes.push(substr)\n\n  }\n\n  static removeBinaryContentType(val) {\n    for(let i in XMLHttpRequest.binaryContentTypes) {\n      if(new RegExp(substr,'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n        XMLHttpRequest.binaryContentTypes.splice(i,1)\n        return\n      }\n    }\n  }\n\n  constructor() {\n    log.verbose('XMLHttpRequest constructor called')\n    super()\n  }\n\n\n  /**\n   * XMLHttpRequest.open, always async, user and password not supported. When\n   * this method invoked, headers should becomes empty again.\n   * @param  {string} method Request method\n   * @param  {string} url Request URL\n   * @param  {true} async Always async\n   * @param  {any} user NOT SUPPORTED\n   * @param  {any} password NOT SUPPORTED\n   */\n  open(method:string, url:string, async:true, user:any, password:any) {\n    log.verbose('XMLHttpRequest open ', method, url, async, user, password)\n    this._method = method\n    this._url = url\n    this._headers = {}\n    this._increment = URIUtil.isJSONStreamURI(this._url)\n    this._url = this._url.replace(/^JSONStream\\:\\/\\//, '')\n    this._dispatchReadStateChange(XMLHttpRequest.OPENED)\n  }\n\n  /**\n   * Invoke this function to send HTTP request, and set body.\n   * @param  {any} body Body in RNfetchblob flavor\n   */\n  send(body) {\n\n    this._body = body\n\n    if(this._readyState !== XMLHttpRequest.OPENED)\n      throw 'InvalidStateError : XMLHttpRequest is not opened yet.'\n    let promise = Promise.resolve()\n    this._sendFlag = true\n    log.verbose('XMLHttpRequest send ', body)\n    let {_method, _url, _headers } = this\n    log.verbose('sending request with args', _method, _url, _headers, body)\n    log.verbose(typeof body, body instanceof FormData)\n\n    if(body instanceof Blob) {\n      log.debug('sending blob body', body._blobCreated)\n      promise = new Promise((resolve, reject) => {\n          body.onCreated((blob) => {\n            // when the blob is derived (not created by RN developer), the blob\n            // will be released after XMLHttpRequest sent\n            if(blob.isDerived) {\n              this._cleanUp = () => {\n                blob.close()\n              }\n            }\n            log.debug('body created send request')\n            body = RNFetchBlob.wrap(blob.getRNFetchBlobRef())\n            resolve()\n          })\n        })\n    }\n    else if(typeof body === 'object') {\n      body = JSON.stringify(body)\n      promise = Promise.resolve()\n    }\n    else {\n      body = body ? body.toString() : body\n      promise = Promise.resolve()\n    }\n\n    promise.then(() => {\n      log.debug('send request invoke', body)\n      for(let h in _headers) {\n        _headers[h] = _headers[h].toString()\n      }\n\n      this._task = RNFetchBlob\n                    .config({\n                      auto: true,\n                      timeout : this._timeout,\n                      increment : this._increment,\n                      binaryContentTypes : XMLHttpRequest.binaryContentTypes\n                    })\n                    .fetch(_method, _url, _headers, body)\n      this._task\n          .stateChange(this._headerReceived)\n          .uploadProgress(this._uploadProgressEvent)\n          .progress(this._progressEvent)\n          .catch(this._onError)\n          .then(this._onDone)\n\n    })\n  }\n\n  overrideMimeType(mime:string) {\n    log.verbose('XMLHttpRequest overrideMimeType', mime)\n    this._headers['Content-Type'] = mime\n  }\n\n  setRequestHeader(name, value) {\n    log.verbose('XMLHttpRequest set header', name, value)\n    if(this._readyState !== OPENED || this._sendFlag) {\n      throw `InvalidStateError : Calling setRequestHeader in wrong state  ${this._readyState}`\n    }\n    // UNICODE SHOULD NOT PASS\n    if(typeof name !== 'string' || /[^\\u0000-\\u00ff]/.test(name)) {\n      throw 'TypeError : header field name should be a string'\n    }\n    //\n    let invalidPatterns = [\n      /[\\(\\)\\>\\<\\@\\,\\:\\\\\\/\\[\\]\\?\\=\\}\\{\\s\\ \\u007f\\;\\t\\0\\v\\r]/,\n      /tt/\n    ]\n    for(let i in invalidPatterns) {\n      if(invalidPatterns[i].test(name) || typeof name !== 'string') {\n        throw `SyntaxError : Invalid header field name ${name}`\n      }\n    }\n    this._headers[name] = value\n  }\n\n  abort() {\n    log.verbose('XMLHttpRequest abort ')\n    if(!this._task)\n      return\n    this._task.cancel((err) => {\n      let e = {\n        timeStamp : Date.now(),\n      }\n      if(this.onabort)\n        this.onabort()\n      if(err) {\n        e.detail = err\n        e.type = 'error'\n        this.dispatchEvent('error', e)\n      }\n      else {\n        e.type = 'abort'\n        this.dispatchEvent('abort', e)\n      }\n    })\n  }\n\n  getResponseHeader(field:string):string | null {\n    log.verbose('XMLHttpRequest get header', field, this._responseHeaders)\n    if(!this._responseHeaders)\n      return null\n    return (this._responseHeaders[field] || this._responseHeaders[field.toLowerCase()]) || null\n\n  }\n\n  getAllResponseHeaders():string | null {\n    log.verbose('XMLHttpRequest get all headers', this._responseHeaders)\n    if(!this._responseHeaders)\n      return ''\n    let result = ''\n    let respHeaders = this.responseHeaders\n    for(let i in respHeaders) {\n      result += `${i}: ${respHeaders[i]}${String.fromCharCode(0x0D,0x0A)}`\n    }\n    return result.substr(0, result.length-2)\n  }\n\n  _headerReceived = (e) => {\n    log.debug('header received ', this._task.taskId, e)\n    this.responseURL = this._url\n    if(e.state === \"2\" && e.taskId === this._task.taskId) {\n      this._responseHeaders = e.headers\n      this._statusText = e.status\n      this._status = Math.floor(e.status)\n      this._dispatchReadStateChange(XMLHttpRequest.HEADERS_RECEIVED)\n    }\n  }\n\n  _uploadProgressEvent = (send:number, total:number) => {\n    if(!this._uploadStarted) {\n      this.upload.dispatchEvent('loadstart')\n      this._uploadStarted = true\n    }\n    if(send >= total)\n      this.upload.dispatchEvent('load')\n    this.upload.dispatchEvent('progress', new ProgressEvent(true, send, total))\n  }\n\n  _progressEvent = (send:number, total:number, chunk:string) => {\n    log.verbose(this.readyState)\n    if(this._readyState === XMLHttpRequest.HEADERS_RECEIVED)\n      this._dispatchReadStateChange(XMLHttpRequest.LOADING)\n    let lengthComputable = false\n    if(total && total >= 0)\n        lengthComputable = true\n    let e = new ProgressEvent(lengthComputable, send, total)\n\n    if(this._increment) {\n      this._responseText += chunk\n    }\n    this.dispatchEvent('progress', e)\n  }\n\n  _onError = (err) => {\n    let statusCode = Math.floor(this.status)\n    if(statusCode >= 100 && statusCode !== 408) {\n      return\n    }\n    log.debug('XMLHttpRequest error', err)\n    this._statusText = err\n    this._status = String(err).match(/\\d+/)\n    this._status = this._status ? Math.floor(this.status) : 404\n    this._dispatchReadStateChange(XMLHttpRequest.DONE)\n    if(err && String(err.message).match(/(timed\\sout|timedout)/) || this._status == 408) {\n      this.dispatchEvent('timeout')\n    }\n    this.dispatchEvent('loadend')\n    this.dispatchEvent('error', {\n      type : 'error',\n      detail : err\n    })\n    this.clearEventListeners()\n  }\n\n  _onDone = (resp) => {\n    log.debug('XMLHttpRequest done', this._url, resp, this)\n    this._statusText = this._status\n    let responseDataReady = () => {\n      log.debug('request done state = 4')\n      this.dispatchEvent('load')\n      this.dispatchEvent('loadend')\n      this._dispatchReadStateChange(XMLHttpRequest.DONE)\n      this.clearEventListeners()\n    }\n    if(resp) {\n      let info = resp.respInfo || {}\n      log.debug(this._url, info, info.respType)\n      switch(this._responseType) {\n        case 'blob' :\n          resp.blob().then((b) => {\n            this._responseText = resp.text()\n            this._response = b\n            responseDataReady()\n          })\n        break;\n        case 'arraybuffer':\n          // TODO : to array buffer\n        break\n        case 'json':\n          this._response = resp.json()\n          this._responseText = resp.text()\n        break\n        default :\n          this._responseText = resp.text()\n          this._response = this.responseText\n          responseDataReady()\n        break;\n      }\n    }\n\n  }\n\n  _dispatchReadStateChange(state) {\n    this._readyState = state\n    if(typeof this._onreadystatechange === 'function')\n      this._onreadystatechange()\n  }\n\n  set onreadystatechange(fn:() => void) {\n    log.verbose('XMLHttpRequest set onreadystatechange', fn)\n    this._onreadystatechange = fn\n  }\n\n  get onreadystatechange() {\n    return this._onreadystatechange\n  }\n\n  get readyState() {\n    log.verbose('get readyState', this._readyState)\n    return this._readyState\n  }\n\n  get status() {\n    log.verbose('get status', this._status)\n    return this._status\n  }\n\n  get statusText() {\n    log.verbose('get statusText', this._statusText)\n    return this._statusText\n  }\n\n  get response() {\n    log.verbose('get response', this._response)\n    return this._response\n  }\n\n  get responseText() {\n    log.verbose('get responseText', this._responseText)\n    return this._responseText\n  }\n\n  get responseURL() {\n    log.verbose('get responseURL', this._responseURL)\n    return this._responseURL\n  }\n\n  get responseHeaders() {\n    log.verbose('get responseHeaders', this._responseHeaders)\n    return this._responseHeaders\n  }\n\n  set timeout(val) {\n    this._timeout = val*1000\n    log.verbose('set timeout', this._timeout)\n  }\n\n  get timeout() {\n    log.verbose('get timeout', this._timeout)\n    return this._timeout\n  }\n\n  set responseType(val) {\n    log.verbose('set response type', this._responseType)\n    this._responseType = val\n  }\n\n  get responseType() {\n    log.verbose('get response type', this._responseType)\n    return this._responseType\n  }\n\n  static get isRNFBPolyfill() {\n    return true\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}